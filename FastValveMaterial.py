""" Simple Source Material "PBR" generator

Prerequisites (Python 3.x):
pillow

MIT License

Copyright (c) 2024 Marvin Friedrich, hampta

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. """


import configparser

import os
import shutil
import sys
import logging
from ctypes import create_string_buffer
from pathlib import Path
from enum import Enum

from PIL import Image, ImageChops, ImageOps

import VTFLibWrapper.VTFLib as VTFLib
import VTFLibWrapper.VTFLibEnums as VTFLibEnums

vtf_lib = VTFLib.VTFLib()
version = "240212"


class TextureType(Enum):
    DIFFUSE = 'c'
    NORMAL = 'n'
    EXPONENT = 'm'


VMT_TEMPLATE = """// Generated by FastValveMaterial v{version} 
// Forked by hampta because the original sucks
// METALNESS: "{metallic_factor}" GAMMA: "{midtone}"
"VertexLitGeneric"
{{
    "$basetexture" "{output_path}/{material_name}_c"
    "$bumpmap" "{output_path}/{material_name}_n"
    "$phongexponenttexture" "{output_path}/{material_name}_m"
    "$color2" "[ .1 .1 .1 ]"
    "$blendtintbybasealpha" "1"
    "$phong" "1"
    "$phongboost" "10"
    "$phongalbedotint" "1"
    {phong}
    "$envmap" "env_cubemap"
    "$basemapalphaenvmapmask" "1"
    "$envmapfresnel" "0.4"
    "$envmaptint" "[ .1 .1 .1 ]"
    {proxies}
}}"""

VMT_NORMAL_TEMPLATE = """// Generated by FastValveMaterial v{version}
// Forked by hampta because the original sucks
// NORMALIZED MATERIAL!
"VertexLitGeneric"
{{
    "$basetexture" "{output_path}/{material_name}_c"
    "$bumpmap" "{output_path}/{material_name}_n"
    "$phongexponenttexture" "{output_path}/{material_name}_m"
    "$phong" "1"
    "$phongboost" "1"
    "$color2" "[ 0 0 0 ]"
    "$phongexponent"    "24"
    "$phongalbedotint" "1"
    "$additive"    "1"
    "$PhongFresnelRanges" "[ 2 4 6 ]"
    {proxies}
}}"""
    
PROXIES_TEMPLATE = """\
"Proxies"
    {
        "MwEnvMapTint"
        {
            "min" "0"
            "max" "0.015"
        }
    }"""

class Config:
    def __init__(self) -> None:
        __config = configparser.ConfigParser()
        __config.read("config.ini")
        # Input
        self.input_format = __config["Input"]["Format"]
        self.input_scale = __config["Input"].getfloat("Scale")
        self.input_color = __config["Input"]["Color"]
        self.input_ao = __config["Input"]["AO"]
        self.input_normal = __config["Input"]["Normal"]
        self.input_metallic = __config["Input"]["Metallic"]
        self.input_roughness = __config["Input"]["Roughness"]
        self.input_path = Path(__config["Input"]["Path"])
        # Output
        self.output_path = Path(__config["Output"]["Path"])
        self.midtone = __config["Output"].getint("Midtone")
        self.export_images = __config["Output"].getboolean("ExportImages")
        self.material_setup = __config["Output"]["MaterialSetup"]
        # Debug
        self.debug_messages = __config["Debug"].getboolean("DebugMessages")
        self.info_config = __config["Debug"].getboolean("PrintConfig")
        self.force_compression = __config["Debug"].getboolean("ForceCompression")
        self.fast_export = __config["Debug"].getboolean("FastExport")
        self.clear_exponent = __config["Debug"].getboolean("ClearExponent")
        self.metallic_factor = __config["Debug"].getint("MetallicFactor")
        self.material_proxies = __config["Debug"].getboolean("MaterialProxies")
        self.orm = __config["Debug"].getboolean("ORM")
        self.phongwarps = __config["Debug"].getboolean("Phongwarps")


config = Config()

handler = logging.StreamHandler(sys.stdout)
handler.terminator = "\r"

logging.basicConfig(level=logging.info if config.debug_messages else logging.INFO,
                    format='[FVM] [%(levelname)s] %(message)s', handlers=[handler])
logging.info(f"FastValveMaterial (v{version}" + ")\n")


# Check if a file in "path" starts with the desired "name" and ends with "ending"
def check_for_valid_files(path: str, name: str, ending: str):
    for file in os.listdir(path):
        # ? Works in theory, but is busted if materials start with the same prefix
        if file.endswith(ending) and file.startswith(name + ending):
            return file


def replace_list(string, list):
    for i in list:
        string = string.replace(i, "")
    return string


def find_material_names():  # Uses the color map to determine the current material name
    list_stuff = []
    for file in os.listdir(config.input_path):
        # If file ends with "scheme.format
        if file.endswith(config.input_format):
            # Get rid of "scheme.format" to get the material name and append it to the list of all materials
            material_name = replace_list(file, [f".{config.input_format}",
                                                config.input_color, config.input_ao,
                                                config.input_normal, config.input_metallic,
                                                config.input_roughness])
            list_stuff.append(material_name)
    return list(set(list_stuff))


def do_diffuse(color_image: Image.Image, ao_image: Image.Image,
               metallic_image: Image.Image, glossiness_image: Image.Image, material_name: str):  # Generate Diffuse/Color map
    final_diffuse = color_image.convert("RGBA")
    if ao_image is None:
        final_diffuse = ImageChops.blend(final_diffuse.convert("RGB"),
                                         ImageChops.multiply(final_diffuse.convert("RGB"), 
                                                             glossiness_image.convert("RGB")), 0.3).convert("RGBA")  # Combine diffuse and glossiness map
    else:
        final_diffuse = ImageChops.multiply(final_diffuse.convert("RGB"),
                                            ao_image.convert("RGB")).convert("RGBA")  # Combine diffuse and occlusion map
    # Split diffuse image into channels to modify alpha
    r, g, b, a = final_diffuse.split()
    # * I think i forgot to remove some excess conversion but i literally cannot be asked to do so
    # Blend the alpha channel with metal_image
    a = Image.blend(a.convert("L"), metallic_image.convert("L"),
                    config.metallic_factor / 255 * 0.83).convert("L")
    color_spc = (r, g, b, a)
    # Merge all channels together
    final_diffuse = Image.merge("RGBA", color_spc)
    logging.info("Exporting Diffuse...\n")
    export_texture(final_diffuse, material_name, TextureType.DIFFUSE, 'DXT5')


def do_exponent(glossiness_image: Image.Image, material_name: str):  # Generate the exponent map
    final_exponent = glossiness_image.convert("RGBA")
    r, g, b, a = final_exponent.split()
    layerImage = Image.new('RGBA',
                           [final_exponent.size[0], final_exponent.size[1]],
                           (0, 217, 0, 100))
    blackImage = Image.new('RGBA',
                           [final_exponent.size[0], final_exponent.size[1]],
                           (0, 0, 0, 100))
    final_exponent = Image.blend(final_exponent, layerImage, 0.5)
    g = g.convert('RGBA')
    b = b.convert('RGBA')
    g = Image.blend(g, layerImage, 1).convert('L')
    b = Image.blend(b, blackImage, 1).convert('L')
    if config.clear_exponent:
        g = Image.new('L', [final_exponent.size[0], final_exponent.size[1]], 255)
    colorSpc = (r, g, b, a)
    final_exponent = Image.merge('RGBA', colorSpc)
    logging.info("Exporting Exponent...\n")
    export_texture(final_exponent, material_name,
                   TextureType.EXPONENT, 'DXT5' if config.force_compression else 'DXT1')


def do_normal(normalmap_image: Image.Image, glossiness_image: Image.Image, material_name: str):  # Generate the normal map
    final_normal = normalmap_image.convert('RGBA')
    final_gloss = glossiness_image.convert('RGBA')
    final_gloss = do_gamma(final_gloss, config.midtone)
    r, g, b, a = final_normal.split()
    a = Image.blend(a, final_gloss.convert('L'), 1).convert('L')
    colorSpc = (r, g, b, a)
    final_normal = Image.merge('RGBA', colorSpc)
    logging.info("Exporting Normal Map...\n")
    export_texture(final_normal, material_name,
                   TextureType.NORMAL, 'DXT5' if config.force_compression else 'RGBA8888')


def do_gamma(image: Image.Image, gamma: float):
    gamma = 1
    midToneNormal = gamma / 255
    if gamma < 128:
        midToneNormal = midToneNormal * 2
        gamma = 1 + (9 * (1 - midToneNormal))
        gamma = min(gamma, 9.99)
    elif gamma > 128:
        midToneNormal = (midToneNormal * 2) - 1
        gamma = 1 - midToneNormal
        gamma = max(gamma, 0.01)
    gamma_correction = 1 / gamma
    if gamma != 128:
        return image.point(lambda x: ((x/255)**gamma_correction)*255)
    return image


# Resize the target image to be the same as image (needed for normal maps)
def fix_scale_mismatch(image: Image.Image, target: Image.Image):
    factor = image.height / target.height
    return ImageOps.scale(target, factor)


def do_material(material_name: str):  # Create a material with the given image names
    logging.debug(f"Creating material '{material_name}'\n")
    if "materials" in config.output_path.parts:
        texture_local_path = "/".join(config.output_path.parts[config.output_path.parts.index("materials") + 1:])
    else:
        texture_local_path = config.output_path
    writer = VMT_TEMPLATE.format(
        version=version, config=config,
        output_path=texture_local_path,
        material_name=material_name,
        metallic_factor=config.metallic_factor,
        midtone=config.midtone, 
        phong=f'"$phongwarptexture" "{texture_local_path}/phongwarp_steel"' if config.phongwarps else '"$PhongFresnelRanges" "[ 4 3 10 ]"',
        proxies=PROXIES_TEMPLATE if config.material_proxies else "")
    try:
        Path(config.output_path).mkdir(parents=True, exist_ok=True)
        with open(f"{material_name}.vmt", 'w') as f:
            f.writelines(writer)
        shutil.move(f'{material_name}.vmt', config.output_path)
        shutil.copy("phongwarp_steel.vtf", config.output_path)
        # ? Spaces are needed in order to overwrite the progress count, otherwise about 4 chars will stay on screen (?????)
        logging.debug("Material exported\n")
    except Exception as e:
        logging.debug("Material already exists, replacing!\n")
        shutil.copy("phongwarp_steel.vtf", config.output_path)
        shutil.copyfile(os.path.join(os.getcwd(), f"{material_name}.vmt"),
                        os.path.join(os.getcwd(), config.output_path, f"{material_name}.vmt"), follow_symlinks=True)
        os.remove(os.path.join(os.getcwd(), f"{material_name}.vmt"))


def do_nrm_material(material_name: str):
    logging.info(f"Creating NRM material '{material_name}' \n")
    if "materials" in config.output_path.parts:
        texture_local_path = "/".join(config.output_path.parts[config.output_path.parts.index("materials") + 1:])
    else:
        texture_local_path = config.output_path
    writer = VMT_NORMAL_TEMPLATE.format(
        version=version, config=config,
        output_path=texture_local_path,
        material_name=material_name,
        proxies=PROXIES_TEMPLATE if config.material_proxies else "")
    try:
        Path("materials/").mkdir(parents=True, exist_ok=True)
        with open(f"{material_name}_s.vmt", 'w') as f:
            f.writelines(writer)
        shutil.move(f'{material_name}_s.vmt', "materials/")
    except Exception as e:
        logging.info("Normalized material already exists, replacing!\n")
        shutil.copyfile(os.path.join(os.getcwd(), f"{material_name}_s.vmt"),
                        os.path.join(os.getcwd(), config.output_path, f"{material_name}_s.vmt"), follow_symlinks=True)
        os.remove(os.path.join(os.getcwd(), f"{material_name}_s.vmt"))


# Exports an image to VTF using VTFLib
def export_texture(texture: Image.Image, material_name: str, texture_type: TextureType, imageFormat=None):
    image_name = f'{material_name}_{texture_type.value}.vtf'
    output_path = Path(f'{config.output_path}\\{image_name}')
    def_options = vtf_lib.create_default_params_structure()
    if imageFormat.startswith('RGBA8888') or config.fast_export:
        def_options.ImageFormat = VTFLibEnums.ImageFormat.ImageFormatRGBA8888
        def_options.Flags |= VTFLibEnums.ImageFlag.ImageFlagEightBitAlpha
        if imageFormat == 'RGBA8888Normal':
            def_options.Flags |= VTFLibEnums.ImageFlag.ImageFlagNormal
    elif imageFormat.startswith('DXT1'):
        def_options.ImageFormat = VTFLibEnums.ImageFormat.ImageFormatDXT1
        if imageFormat == 'DXT1Normal':
            def_options.Flags |= VTFLibEnums.ImageFlag.ImageFlagNormal
    elif imageFormat.startswith('DXT5'):
        def_options.ImageFormat = VTFLibEnums.ImageFormat.ImageFormatDXT5
        def_options.Flags |= VTFLibEnums.ImageFlag.ImageFlagEightBitAlpha
        if imageFormat == 'DXT5Normal':
            def_options.Flags |= VTFLibEnums.ImageFlag.ImageFlagNormal
    else:
        def_options.ImageFormat = VTFLibEnums.ImageFormat.ImageFormatRGBA8888
        def_options.Flags |= VTFLibEnums.ImageFlag.ImageFlagEightBitAlpha

    def_options.Resize = 1
    w, h = texture.size
    image_data = create_string_buffer(texture.tobytes())
    vtf_lib.image_create_single(w, h, image_data, def_options)
    vtf_lib.image_save(image_name)
    vtf_lib.image_destroy()

    if os.path.exists(output_path):
        logging.debug(f"{texture_type.name} already exists, replacing!\n")
        src = os.path.join(os.getcwd(), image_name)
        dst = os.path.join(os.getcwd(), output_path)
        shutil.copyfile(src, dst, follow_symlinks=True)
        os.remove(os.path.join(os.getcwd(), image_name))
    else:
        Path(config.output_path).mkdir(parents=True, exist_ok=True)
        shutil.move(image_name, os.path.join(os.getcwd(), config.output_path))
        logging.debug(f"{texture_type.name} exported\n")

    path = image_name.replace(".vtf", ".tga")

    if config.export_images:
        texture.save(f"{config.output_path}{path}", "TGA")
        logging.debug(f"Exported {path} as TGA\n")


# /////////////////////
# Main loop
# /////////////////////
def main():
    for material_name in find_material_names():  # For every material in the input folder
        logging.info("Loading...\n")
        try:
            logging.info(f"Material:\t{material_name}\n")
            # Set the paths to the textures based on the config file
            if config.orm:
                color_textute_path = f'{config.input_path}/{check_for_valid_files(config.input_path, material_name, f"{config.input_color}.{config.input_format}")}'
                aoSt = f'{config.input_path}/{check_for_valid_files(config.input_path, material_name, f"{config.input_roughness}.{config.input_format}")}'
                normal_textute_path = f'{config.input_path}/{check_for_valid_files(config.input_path, material_name, f"{config.input_normal}.{config.input_format}")}'
                metal_textute_path = f'{config.input_path}/{check_for_valid_files(config.input_path, material_name, f"{config.input_roughness}.{config.input_format}")}'
                glossSt = f'{config.input_path}/{check_for_valid_files(config.input_path, material_name, f"{config.input_roughness}.{config.input_format}")}'
            else:
                color_textute_path = f'{config.input_path}/{check_for_valid_files(config.input_path, material_name, f"{config.input_color}.{config.input_format}")}'
                if config.input_ao != '':  # If a map is set
                    aoSt = f'{config.input_path}/{check_for_valid_files(config.input_path, material_name, f"{config.input_ao}.{config.input_format}")}'
                if config.input_normal != '':
                    normal_textute_path = f'{config.input_path}/{check_for_valid_files(config.input_path, material_name, f"{config.input_normal}.{config.input_format}")}'
                if config.input_roughness != '':
                    glossSt = f'{config.input_path}/{check_for_valid_files(config.input_path, material_name, f"{config.input_roughness}.{config.input_format}")}'
                if config.input_metallic != '':
                    metal_textute_path = f'{config.input_path}/{check_for_valid_files(config.input_path, material_name, f"{config.input_metallic}.{config.input_format}")}'
        except FileNotFoundError:
            logging.info(f"[ERROR] v{version} terminated with exit code -1:\n \
                            Couldn't locate files with correct naming scheme, throwing FileNotFoundError!\n")
            sys.exit()

        if not config.orm:
            logging.info(f"Color:\t\t{color_textute_path}\n")
            if config.input_ao != '':
                logging.info(f"Occlusion:\t\t{aoSt}\n")
            else:
                logging.info("Occlusion:\t\t None given, ignoring!\n")
            if config.input_normal != '':
                logging.info(f"Normal:\t\t{normal_textute_path}\n")
            else:
                logging.info("Normal:\t\t None given, ignoring!\n")
            if config.input_metallic != '':
                logging.info(f"Metalness:\t\t{metal_textute_path}\n")
            else:
                logging.info("Metalness:\t\t None given, ignoring!\n")
            if config.input_roughness != '':
                logging.info(f"Glossiness:\t{glossSt}\n")
            else:
                logging.info("Glossiness:\t\tNone given, ignoring!\n\n")

            color_image = Image.open(color_textute_path)
            color_image = color_image.resize((int(color_image.width * config.input_scale),
                                            int(color_image.height * config.input_scale)),
                                           Image.Resampling.LANCZOS)

            if config.input_ao != '':
                ao_image = Image.open(aoSt)
                ao_image = ao_image.resize((int(ao_image.width * config.input_scale),
                                          int(ao_image.height * config.input_scale)),
                                         Image.Resampling.LANCZOS)
            else:
                # If no AO image is given, use a white image
                ao_image = Image.new(
                    'RGB', (color_image.width, color_image.height), (255, 255, 255))

            if config.input_normal != '':
                normal_image = Image.open(normal_textute_path)
                normal_image = normal_image.resize((int(normal_image.width * config.input_scale),
                                                  int(normal_image.height * config.input_scale)),
                                                 Image.Resampling.LANCZOS)
            else:
                raise FileNotFoundError()  # Couldn't find a normal map

            if config.input_metallic != '':
                metal_image = Image.open(metal_textute_path)
                metal_image = metal_image.resize((int(metal_image.width * config.input_scale),
                                                int(metal_image.height * config.input_scale)),
                                               Image.Resampling.LANCZOS)
            else:
                # If no Metalness image is given, use a black image
                metal_image = Image.new(
                    'RGB', (color_image.width, color_image.height), (0, 0, 0))

            if config.input_roughness != '':
                gloss_image = Image.open(glossSt)
                gloss_image = gloss_image.resize((int(gloss_image.width * config.input_scale),
                                                int(gloss_image.height * config.input_scale)),
                                               Image.Resampling.LANCZOS)
            else:
                # If no Gloss image is given, use a white image
                gloss_image = Image.new(
                    'RGB', (color_image.width, color_image.height), (255, 255, 255))

            if config.material_setup == "rough":
                gloss_image = ImageOps.invert(gloss_image.convert('RGB'))
                
            ao_image = fix_scale_mismatch(normal_image, ao_image)
            metal_image = fix_scale_mismatch(normal_image, metal_image)
            color_image = fix_scale_mismatch(normal_image, color_image)
            gloss_image = fix_scale_mismatch(normal_image, gloss_image)

            if config.input_ao != '':
                do_diffuse(color_image, ao_image, metal_image,
                           gloss_image, material_name)
            else:
                do_diffuse(color_image, None, metal_image,
                           gloss_image, material_name)

        else:
            logging.info(f"Color:\t\t {color_textute_path}\n")
            logging.info(f"ORM:\t\t {metal_textute_path}\n")
            logging.info(f"Normal:\t\t{normal_textute_path}\n")

            color_image = Image.open(color_textute_path)
            ormImage = Image.open(metal_textute_path)
            normal_image = Image.open(normal_textute_path)
            if ormImage.width != color_image.width or ormImage.height != color_image.height:
                ormImage = ormImage.resize((color_image.width, color_image.height),
                                           Image.Resampling.LANCZOS)
            try:
                (ao_image, roughness, metal_image, _) = ormImage.split()
            except Exception:
                logging.info(
                    "ERROR: Could not convert color bands on ORM! (Do you have empty image channels?)\n")
            gloss_image = ImageOps.invert(roughness.convert('RGB'))
            do_diffuse(color_image, ao_image, metal_image,
                       gloss_image, material_name)
        do_exponent(gloss_image, material_name)
        do_normal(normal_image, gloss_image, material_name)
            
        if (config.clear_exponent):
            do_nrm_material(material_name)
        else:
            do_material(material_name)
        logging.info(
            f"Conversion for material '{material_name}' finished, files saved to '{config.output_path}'\n")


if __name__ == "__main__":
    main()
    logging.debug(
        f"v{version} finished with exit code 0: All conversions finished.\n")
    if (config.info_config):
        logging.info("Config file dump:\n")
        logging.info(config)
